package hw3;

//Do not edit this file for the homework.
//This exercises your TwoEC on a SymbolGraph (some input file).

public class Driver
{
 // On command line, we expect two arguments: FILENAME SEPARATOR
 public static void main(String[] args)
 {
     run(args[0], args[1]);
 }

 // We hardwire some input test cases (resembling Makefile),
 // in case you want to invoke these from within BlueJ or Eclipse.
 public static void run1() { run("run1.txt", "/"); }
 public static void run2() { run("run2.txt", "/"); }
 public static void run3() { run("run3.txt", "/"); }
 public static void run4() { run("run4.txt", "/"); }
 public static void movies() { run("movies.txt", "/"); }

 public static void run(String fileName, String sep)
 {
     StdOut.println("Reading " + fileName +
                    " with separator '" + sep + "' ...");
     SymbolGraph M = new SymbolGraph(fileName, sep);
     Graph G = M.G();        // underlying Graph object
     StdOut.println("Done, got graph object G");

     // First some basics: how big is G?
     int V = G.V(), E = G.E();
     StdOut.println("G has " + V + " vertices and " + E + " edges");

     // How many components?
     CC cc = new CC(G);
     StdOut.println("G has " + cc.count() + " connected components");

     // How many 2EC components?
     TwoEC tec = new TwoEC(G);
     StdOut.println("G has " + tec.count() + " 2EC components");

     // Report the first vertex and size of each component.
     // We assume all ids are in the range 0 to V-1.
     int[] id2v = new int[V];
     int  sumSizes=0, countSize1 = 0;
     for (int id=0; id<V; ++id) id2v[id] = -1;
     for (int v=0; v<V; ++v)
     {
         int id = tec.id(v);
         if (id2v[id] == -1)
         {
             // v is the first vertex with this id, save it
             id2v[id] = v;
             int sizev = tec.size(v);
             if (sizev == 1)
                 ++countSize1;
             else
                 StdOut.println(M.name(v) + " is first in a 2EC component of size "
                                + sizev);
             sumSizes += sizev;
         } else {
             if (tec.size(v) != tec.size(id2v[id]))
                 StdOut.println("Warning: " + M.name(v) + " has inconsistent size(v)");
         }
     }
     if (countSize1 > 0)
         StdOut.println("Also saw " + countSize1 + " 2EC components of size one");
     if (sumSizes != V)
         StdOut.println("WARNING: those sizes sum to " + sumSizes + ", not " + V);
     // here we print bridge edges where both sides have size >= 2
     StdOut.println("Big bridges (both sides having 2EC size at least 2):");
     for (int v=0; v<V; ++v)
         if (tec.size(v) >= 2)
         for (int w: G.adj(v))
             if (w > v && tec.id(v) != tec.id(w) && tec.size(w) >= 2)
                 StdOut.println(M.name(v) + " (size " + tec.size(v) + ") to " +
                                M.name(w) + " (size " + tec.size(w) + ")");
     StdOut.println("Done.");
 }
}

